Multilingual Dynamic Content Plan (Frontend + Backend CRUD)

Goal
- Serve all dynamic content (news, publications, success stories, etc.) in the user’s selected language using one master translations table.
- Keep i18n (useI18n) for static UI strings; resolve dynamic data on the server by lang with clean fallbacks.
- Ensure Admin CRUD supports creating/editing translations per model/field/language.

1) Data Model (DONE)
- tables:
  - base tables (news, publications, success_stories, ...): store default language content (en) in normal columns.
  - translations (polymorphic): id, model_type, model_id, field_name, language (en|fa|ps), content, timestamps.
- model helpers:
  - getTranslation(field, lang): returns translated content or null if missing.
  - Accessor pattern (preferred in Resources): prefer $this->getTranslation('title',$lang) ?? $this->title.
- DB constraints:
  - unique key: (model_type, model_id, field_name, language) to avoid duplicates.

2) API Contract (every dynamic endpoint)
- Accept ?lang=en|fa|ps; default en.
- Resolve translatable fields by lang on the server; include base fallback.
- Optional query: include_translations=1 to return full translations array for Admin or UI preview.
- Pagination responses remain unchanged.

3) Laravel Resources update (server-side resolution)
- NewsResource, PublicationResource, SuccessStoryResource, etc.:
  - Read $lang = $request->get('lang','en').
  - For each translatable field (title, excerpt, content, description, client_name, etc.) return:
    - 'title' => $this->getTranslation('title',$lang) ?? $this->title
  - Keep URLs, dates, ids unchanged.
- Add a small base Resource trait (optional) to DRY the lookup logic.

4) Admin CRUD (to support translations)
- Admin UI per model (News, Publications, Success Stories, etc.):
  - Base (default) language tab: edit normal columns (en).
  - Language tabs (fa, ps): for each translatable field show inputs bound to translations table.
  - Auto-create translation rows on save if content is present; update existing rows if present; delete row if translation is cleared.
  - Validation: allow empty translation; base language still required based on model rules.
- API Admin endpoints additions:
  - POST/PUT accepts translations payload per language: { translations: { fa: { title, excerpt, content }, ps: {...} } }
  - Backend service saves/updates translations accordingly.
  - GET (admin show) can return include_translations=1 for editing.

5) Frontend Integration (Vue)
- Static UI: continue to use useI18n().
- Dynamic content requests: always send current locale.
  - Create axiosLang.ts helper (or interceptor):
    - import { useI18n } from '...';
    - attaches params.lang = currentLanguage for all /api/* calls by default (configurable).
  - Watch language change: re-fetch current page lists/details when language switches.
- Components to update data fetch with lang (minimal because interceptor handles it):
  - Home (latest news)
  - Resources (news list, publications, success stories)
  - NewsDetail, SuccessStoryDetail
  - Any other pages rendering dynamic DB content

5.1) Pillars (dynamic) — clarify and support
- Confirm existing tables per pillar (training_programs, agri_tech_tools, smart_farming_programs, seed_supply_programs, market_access_programs, environmental_projects, community_programs).
- For each index and detail endpoint, accept ?lang and resolve translatable fields via master translations.
- Add Pillar meta endpoint (optional) /api/pillars to return per-pillar localized title/description used on Home and landing pages.
- Frontend: Home pillars section should be driven by API (not hardcoded strings) once backend meta is available.

6) Fallback & Edge Cases
- If a translation is missing: server returns base language value (en).
- If the base language field is empty (shouldn’t happen): return empty string.
- For SEO (if required later): add route variants per lang or query param canonicalization (out of scope now).

7) Performance & Caching (recommended)
- Eloquent relation eager-load: translations relation to avoid N+1.
- Cache resolved (model_id, lang) field map for show pages.
- Invalidate cache on create/update/delete of base or translation rows.

8) Testing Plan
- Unit tests (Laravel):
  - Resource resolution returns translated fields for fa/ps; base for en; fallback when translation missing.
  - Admin save updates translations table (create/update/delete scenarios).
- Feature tests (API): lists & details return correctly resolved texts for each lang parameter.
- Frontend smoke tests: switch language and verify content text changes (Cypress optional).

9) Migration/Backfill
- Ensure translations table uses the unique index.
- Script (artisan command) to backfill legacy content into translations if needed (optional).

10) Rollout Steps
- Backend: update Resources & controllers to read ?lang and resolve fields.
- Admin: extend forms to include tabs per language with translations payload.
- Frontend: add axios interceptor to attach lang; refetch on language switch.
- QA in three languages; validate fallbacks.

11) Nice-to-Haves (later)
- Slug translation strategy (either keep single canonical slug or per-language slug map).
- RTL layout toggle per language (already partly in App.vue; finish once styles are ready).
- Search endpoints: add full-text search by translations (join translations by field_name).

Deliverables
- Updated Resources with lang-based resolution and fallbacks.
- Admin CRUD endpoints handling translations payload.
- Frontend axios lang propagation + refetch on locale change.
- Documentation of translatable fields per model.


